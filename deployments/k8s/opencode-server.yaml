apiVersion: v1
kind: Service
metadata:
  name: opencode-server
  namespace: bot
spec:
  selector:
    app: opencode-server
  ports:
    - name: http
      port: 4096
      targetPort: http
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: opencode-server
  namespace: bot
spec:
  replicas: 1
  selector:
    matchLabels:
      app: opencode-server
  template:
    metadata:
      labels:
        app: opencode-server
    spec:
      containers:
        - name: opencode-server
          image: registry.cn-shanghai.aliyuncs.com/talesofai/opencode-bot-agent:latest
          command: ["bash", "-lc"]
          args:
            - |
              set -euo pipefail

              if ! command -v git >/dev/null 2>&1; then
                echo "git not found; installing..." >&2
                export DEBIAN_FRONTEND=noninteractive
                apt-get update
                apt-get install -y --no-install-recommends git
                rm -rf /var/lib/apt/lists/*
              fi

              # Opencode's Web UI resolves the current project via git, then lists sessions by `project.worktree`.
              # To make `/data` a real project (and thus show sessions under `/data`), we keep `/data` as a tiny git repo.
              if [ ! -d /data/.git ]; then
                git init /data
              fi

              if [ ! -f /data/.gitignore ]; then
                cat > /data/.gitignore <<'EOF'
              *
              !.gitignore
              EOF
              fi

              git -C /data config user.email "opencode@local"
              git -C /data config user.name "opencode"
              git -C /data config status.showUntrackedFiles no

              if ! git -C /data rev-parse HEAD >/dev/null 2>&1; then
                git -C /data add -f .gitignore
                git -C /data commit -m "init"
              fi

              OPENCODE_PROJECT_ID="$(git -C /data rev-parse HEAD)"
              export OPENCODE_PROJECT_ID

              mkdir -p "${HOME}/.local/share/opencode" "${HOME}/.config/opencode"

              if [ -n "${OPENAI_API_KEY:-}" ]; then
                cat > "${HOME}/.local/share/opencode/auth.json" <<EOF
                {
                  "litellm": {
                    "type": "api",
                    "key": "${OPENAI_API_KEY}"
                  }
                }
              EOF
                chmod 600 "${HOME}/.local/share/opencode/auth.json" || true
              fi

              # Generate opencode config from env so OPENCODE_MODELS changes don't require YAML updates.
              cat > /tmp/opencode-config-gen.mjs <<'EOF'
              import * as fs from "node:fs/promises";
              import * as path from "node:path";

              const homeDir = process.env.HOME ?? "/data/opencode-home";
              const configPath = path.join(homeDir, ".config", "opencode", "config.json");
              const raw = (process.env.OPENCODE_MODELS ?? "").trim();
              const models = raw
                ? raw
                    .split(",")
                    .map((entry) => entry.trim())
                    .filter(Boolean)
                : [];
              const unique = Array.from(new Set(models));

              const config = {
                $schema: "https://opencode.ai/config.json",
                ...(unique.length > 0
                  ? {
                      provider: {
                        litellm: {
                          npm: "@ai-sdk/openai-compatible",
                          options: {
                            baseURL: "{env:OPENAI_BASE_URL}",
                          },
                          models: Object.fromEntries(
                            unique.map((name) => [name, { name }]),
                          ),
                        },
                      },
                    }
                  : {}),
                mcp: {
                  talesofai: {
                    type: "remote",
                    url: "https://mcp.talesofai.cn/mcp",
                    enabled: true,
                    timeout: 600000,
                    headers: {
                      "x-token": "{env:NIETA_TOKEN}",
                    },
                  },
                },
              };

              await fs.mkdir(path.dirname(configPath), { recursive: true });
              const tmpPath = `${configPath}.tmp`;
              await fs.writeFile(tmpPath, JSON.stringify(config, null, 2), "utf8");
              await fs.rename(tmpPath, configPath);
              EOF

              bun run /tmp/opencode-config-gen.mjs
              rm -f /tmp/opencode-config-gen.mjs

              # Ensure `/data` exists as a git project in storage so the Web UI can select it.
              projectFile="${HOME}/.local/share/opencode/storage/project/${OPENCODE_PROJECT_ID}.json"
              mkdir -p "$(dirname "$projectFile")"
              now_ms="$(( $(date +%s) * 1000 ))"
              cat > "$projectFile" <<EOF
              {
                "id": "${OPENCODE_PROJECT_ID}",
                "worktree": "/data",
                "vcs": "git",
                "sandboxes": [],
                "time": {
                  "created": ${now_ms},
                  "updated": ${now_ms}
                },
                "icon": {
                  "color": "cyan"
                }
              }
              EOF

              globalProjectFile="${HOME}/.local/share/opencode/storage/project/global.json"
              cat > "$globalProjectFile" <<EOF
              {
                "id": "global",
                "worktree": "/",
                "sandboxes": [],
                "time": {
                  "created": ${now_ms},
                  "updated": ${now_ms}
                },
                "icon": {
                  "color": "cyan"
                }
              }
              EOF

              rm -f "${HOME}/.local/share/opencode/storage/project/data.json" || true

              # Migrate existing session records so the Web UI can list them under a single directory.
              # Opencode stores sessions under `storage/session/<projectID>/` where projectID is `git rev-parse HEAD`.
              # We rewrite all `/data/...` sessions into the `/data` git project and normalize `directory=/data`.
              cat > /tmp/opencode-session-dir-migrate.mjs <<'EOF'
              import * as fs from "node:fs/promises";
              import * as path from "node:path";

              const homeDir = process.env.HOME ?? "/data/opencode-home";
              const targetDirectory = "/data";
              const targetProjectID = (process.env.OPENCODE_PROJECT_ID ?? "").trim();
              if (!targetProjectID) {
                throw new Error("Missing OPENCODE_PROJECT_ID");
              }
              const sessionRoot = path.join(
                homeDir,
                ".local",
                "share",
                "opencode",
                "storage",
                "session",
              );

              function shouldMigrateDirectory(directory) {
                if (typeof directory !== "string") {
                  return false;
                }
                return (
                  directory === targetDirectory || directory.startsWith(`${targetDirectory}/`)
                );
              }

              function getUpdatedTime(parsed) {
                const updated = parsed?.time?.updated;
                return typeof updated === "number" && Number.isFinite(updated) ? updated : 0;
              }

              async function readSessionJson(filePath) {
                try {
                  const raw = await fs.readFile(filePath, "utf8");
                  return JSON.parse(raw);
                } catch {
                  return null;
                }
              }

              async function writeSessionJsonAtomic(filePath, parsed) {
                const tmpPath = `${filePath}.tmp.${process.pid}.${Date.now()}`;
                const content = `${JSON.stringify(parsed, null, 2)}\n`;
                await fs.writeFile(tmpPath, content, "utf8");
                await fs.rename(tmpPath, filePath);
              }

              async function normalizeAndMoveSession(input) {
                const sourcePath = input.sourcePath;
                const filename = input.filename;
                const parsed = input.parsed;

                if (!shouldMigrateDirectory(parsed.directory)) {
                  return;
                }

                const destDir = path.join(sessionRoot, targetProjectID);
                const destPath = path.join(destDir, filename);
                if (
                  sourcePath === destPath &&
                  parsed.directory === targetDirectory &&
                  parsed.projectID === targetProjectID
                ) {
                  return;
                }

                parsed.directory = targetDirectory;
                parsed.projectID = targetProjectID;

                await fs.mkdir(destDir, { recursive: true });

                if (sourcePath !== destPath) {
                  const existing = await readSessionJson(destPath);
                  if (existing && typeof existing === "object") {
                    const existingUpdated = getUpdatedTime(existing);
                    const sourceUpdated = getUpdatedTime(parsed);
                    const winner = existingUpdated >= sourceUpdated ? existing : parsed;
                    if (winner && typeof winner === "object") {
                      winner.directory = targetDirectory;
                      winner.projectID = targetProjectID;
                      await writeSessionJsonAtomic(destPath, winner);
                    }
                    await fs.unlink(sourcePath).catch(() => {});
                    return;
                  }
                }

                await writeSessionJsonAtomic(destPath, parsed);
                if (sourcePath !== destPath) {
                  await fs.unlink(sourcePath).catch(() => {});
                }
              }

              async function migrateOnce() {
                let projectEntries;
                try {
                  projectEntries = await fs.readdir(sessionRoot, { withFileTypes: true });
                } catch {
                  return;
                }

                for (const projectEntry of projectEntries) {
                  if (!projectEntry.isDirectory()) {
                    continue;
                  }

                  const projectRoot = path.join(sessionRoot, projectEntry.name);
                  let entries;
                  try {
                    entries = await fs.readdir(projectRoot, { withFileTypes: true });
                  } catch {
                    continue;
                  }

                  for (const entry of entries) {
                    if (!entry.isFile()) {
                      continue;
                    }
                    const name = entry.name;
                    if (!name.startsWith("ses_") || !name.endsWith(".json")) {
                      continue;
                    }
                    const filePath = path.join(projectRoot, name);
                    const parsed = await readSessionJson(filePath);
                    if (!parsed || typeof parsed !== "object") {
                      continue;
                    }

                    await normalizeAndMoveSession({
                      filename: name,
                      sourcePath: filePath,
                      parsed,
                    });
                  }
                }
              }

              const watch = process.argv.includes("--watch");
              do {
                await migrateOnce();
                if (!watch) {
                  break;
                }
                await new Promise((resolve) => setTimeout(resolve, 30_000));
              } while (true);
              EOF

              # One-shot migration for existing sessions.
              bun /tmp/opencode-session-dir-migrate.mjs || true

              # Background watcher to keep new sessions visible in Web UI without needing worker changes.
              bun /tmp/opencode-session-dir-migrate.mjs --watch >/dev/null 2>&1 &

              opencode_bin=""
              for c in \
                /usr/local/bun/install/global/node_modules/opencode-linux-x64-baseline/bin/opencode \
                /usr/local/bun/install/global/node_modules/opencode-linux-x64/bin/opencode \
                /usr/local/bun/install/global/node_modules/opencode-linux-x64-musl/bin/opencode; do
                if [ -x "$c" ]; then
                  opencode_bin="$c"
                  break
                fi
              done

              if [ -z "$opencode_bin" ]; then
                echo "opencode binary not found" >&2
                exit 1
              fi

              # Opencode's Web UI (1.1.30+) sends `directory` with a trailing slash (e.g. `/data/`),
              # but opencode server treats it as an exact match and returns an empty session list.
              # Run a tiny proxy on :4096 that normalizes directory strings and forwards to the real server on :4097.
              cat > /tmp/opencode-directory-proxy.mjs <<'EOF'
              const upstream =
                process.env.OPENCODE_PROXY_UPSTREAM ?? "http://127.0.0.1:4097";

              function normalizeDirectory(value) {
                if (!value || typeof value !== "string") {
                  return null;
                }
                if (value === "/") {
                  return value;
                }
                return value.replace(/\/+$/, "");
              }

              Bun.serve({
                port: 4096,
                async fetch(req) {
                  const url = new URL(req.url);
                  const directory = url.searchParams.get("directory");
                  const normalizedDirectory = normalizeDirectory(directory);
                  if (normalizedDirectory && normalizedDirectory !== directory) {
                    url.searchParams.set("directory", normalizedDirectory);
                  }

                  const headers = new Headers(req.headers);
                  const headerDirectory = headers.get("x-opencode-directory");
                  const normalizedHeaderDirectory = normalizeDirectory(headerDirectory);
                  if (
                    normalizedHeaderDirectory &&
                    normalizedHeaderDirectory !== headerDirectory
                  ) {
                    headers.set("x-opencode-directory", normalizedHeaderDirectory);
                  }

                  const upstreamUrl = new URL(url.pathname + url.search, upstream);
                  return await fetch(upstreamUrl, {
                    method: req.method,
                    headers,
                    body: req.body,
                    redirect: "manual",
                  });
                },
              });
              EOF

              "$opencode_bin" serve --hostname 127.0.0.1 --port 4097 \
                --cors https://app.opencode.ai \
                --cors https://opencode.ai &
              opencode_pid=$!

              bun /tmp/opencode-directory-proxy.mjs &
              proxy_pid=$!

              cleanup() {
                kill "$opencode_pid" "$proxy_pid" >/dev/null 2>&1 || true
              }
              trap cleanup EXIT INT TERM

              wait -n "$opencode_pid" "$proxy_pid"
              exit_code=$?
              cleanup
              exit "$exit_code"
          env:
            # Store opencode state on the shared /data RWX volume so multiple replicas can serve the same sessions.
            - name: HOME
              value: "/data/opencode-home"
            - name: OPENAI_BASE_URL
              valueFrom:
                secretKeyRef:
                  name: llbot-secrets
                  key: OPENAI_BASE_URL
                  optional: true
            - name: OPENAI_API_KEY
              valueFrom:
                secretKeyRef:
                  name: llbot-secrets
                  key: OPENAI_API_KEY
                  optional: true
            - name: OPENCODE_MODELS
              valueFrom:
                secretKeyRef:
                  name: llbot-secrets
                  key: OPENCODE_MODELS
                  optional: true
            # Optional: enable HTTP basic auth (worker must use the same values).
            - name: OPENCODE_SERVER_USERNAME
              valueFrom:
                secretKeyRef:
                  name: llbot-secrets
                  key: OPENCODE_SERVER_USERNAME
                  optional: true
            - name: OPENCODE_SERVER_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: llbot-secrets
                  key: OPENCODE_SERVER_PASSWORD
                  optional: true
            # MCP token for talesofai MCP server (used by config.json header template).
            - name: NIETA_TOKEN
              valueFrom:
                secretKeyRef:
                  name: llbot-secrets
                  key: NIETA_TOKEN
                  optional: true
          ports:
            - name: http
              containerPort: 4096
          resources:
            requests:
              cpu: 500m
              memory: 512Mi
            limits:
              cpu: 2000m
              memory: 2Gi
          volumeMounts:
            - name: data
              mountPath: /data
      volumes:
        - name: data
          persistentVolumeClaim:
            claimName: bot-data
