apiVersion: v1
kind: Service
metadata:
  name: opencode-server
  namespace: bot
spec:
  selector:
    app: opencode-server
  ports:
    - name: http
      port: 4096
      targetPort: http
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: opencode-server
  namespace: bot
spec:
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: opencode-server
  template:
    metadata:
      labels:
        app: opencode-server
    spec:
      containers:
        - name: opencode-server
          image: registry.cn-shanghai.aliyuncs.com/talesofai/opencode-bot-agent:latest
          imagePullPolicy: Always
          command: ["bash", "-lc"]
          args:
            - |
              set -euo pipefail

              # Required tools must be baked into the image. No runtime installs.
              if ! command -v git >/dev/null 2>&1; then
                echo "Missing required tool: git (bake it into the image)." >&2
                exit 1
              fi
              if ! command -v rg >/dev/null 2>&1; then
                echo "Missing required tool: rg/ripgrep (bake it into the image)." >&2
                exit 1
              fi
              if ! command -v fd >/dev/null 2>&1; then
                if command -v fdfind >/dev/null 2>&1; then
                  ln -sf "$(command -v fdfind)" /usr/local/bin/fd
                else
                  echo "Missing required tool: fd/fd-find (bake it into the image)." >&2
                  exit 1
                fi
              fi

              # Opencode's Web UI resolves the current project via git, then lists sessions by `project.worktree`.
              # To make `/data` a real project (and thus show sessions under `/data`), we keep `/data` as a tiny git repo.
              if [ ! -d /data/.git ]; then
                git init /data
              fi

              cat > /data/.gitignore <<'EOF'
              # Keep /data a lightweight git project for Opencode Web UI, without hiding bot data directories.
              opencode-home/
              **/node_modules/
              **/.bun/
              **/dist/
              EOF

              git -C /data config user.email "opencode@local"
              git -C /data config user.name "opencode"
              git -C /data config status.showUntrackedFiles no

              if ! git -C /data rev-parse HEAD >/dev/null 2>&1; then
                git -C /data add -f .gitignore
                git -C /data commit -m "init"
              else
                if ! git -C /data diff --quiet -- .gitignore; then
                  git -C /data add -f .gitignore
                  git -C /data commit -m "update .gitignore"
                fi
              fi

              # Opencode identifies a git project by its root commit hash (stable across new commits),
              # not by HEAD. Keep this in sync with opencode's `project/current` resolution.
              OPENCODE_PROJECT_ID="$(git -C /data rev-list --max-parents=0 HEAD)"
              export OPENCODE_PROJECT_ID

              mkdir -p "${HOME}/.local/share/opencode" "${HOME}/.config/opencode"

              if [ -n "${OPENAI_API_KEY:-}" ]; then
                cat > "${HOME}/.local/share/opencode/auth.json" <<EOF
                {
                  "litellm": {
                    "type": "api",
                    "key": "${OPENAI_API_KEY}"
                  }
                }
              EOF
                chmod 600 "${HOME}/.local/share/opencode/auth.json" || true
              fi

              # Generate opencode config from env so OPENCODE_MODELS changes don't require YAML updates.
              cat > /tmp/opencode-config-gen.mjs <<'EOF'
              import * as fs from "node:fs/promises";
              import * as path from "node:path";

              const homeDir = process.env.HOME ?? "/data/opencode-home";
              const configPath = path.join(homeDir, ".config", "opencode", "config.json");
              const raw = (process.env.OPENCODE_MODELS ?? "").trim();
              const models = raw
                ? raw
                    .split(",")
                    .map((entry) => entry.trim())
                    .filter(Boolean)
                : [];
              const unique = Array.from(new Set(models));

              const config = {
                $schema: "https://opencode.ai/config.json",
                ...(unique.length > 0
                  ? {
                      provider: {
                        litellm: {
                          npm: "@ai-sdk/openai-compatible",
                          options: {
                            baseURL: "{env:OPENAI_BASE_URL}",
                          },
                          models: Object.fromEntries(
                            unique.map((name) => [name, { name }]),
                          ),
                        },
                      },
                    }
                  : {}),
                mcp: {
                  talesofai: {
                    type: "remote",
                    url: "https://mcp.talesofai.cn/mcp",
                    enabled: true,
                    timeout: 600000,
                    headers: {
                      "x-token": "{env:NIETA_TOKEN}",
                    },
                  },
                },
              };

              await fs.mkdir(path.dirname(configPath), { recursive: true });
              const tmpPath = `${configPath}.tmp`;
              await fs.writeFile(tmpPath, JSON.stringify(config, null, 2), "utf8");
              await fs.rename(tmpPath, configPath);
              EOF

              bun run /tmp/opencode-config-gen.mjs
              rm -f /tmp/opencode-config-gen.mjs

              # Ensure `/data` exists as a git project in storage so the Web UI can select it.
              projectFile="${HOME}/.local/share/opencode/storage/project/${OPENCODE_PROJECT_ID}.json"
              mkdir -p "$(dirname "$projectFile")"
              now_ms="$(( $(date +%s) * 1000 ))"
              cat > "$projectFile" <<EOF
              {
                "id": "${OPENCODE_PROJECT_ID}",
                "worktree": "/data",
                "vcs": "git",
                "sandboxes": [],
                "time": {
                  "created": ${now_ms},
                  "updated": ${now_ms}
                },
                "icon": {
                  "color": "cyan"
                }
              }
              EOF

              globalProjectFile="${HOME}/.local/share/opencode/storage/project/global.json"
              cat > "$globalProjectFile" <<EOF
              {
                "id": "global",
                "worktree": "/",
                "sandboxes": [],
                "time": {
                  "created": ${now_ms},
                  "updated": ${now_ms}
                },
                "icon": {
                  "color": "cyan"
                }
              }
              EOF

              rm -f "${HOME}/.local/share/opencode/storage/project/data.json" || true

              # Opencode may keep multiple project entries pointing at the same worktree (e.g. `/data`).
              # If stale ones remain, `project/current` can resolve to the wrong id and hide sessions.
              cat > /tmp/opencode-project-prune.mjs <<'EOF'
              import * as fs from "node:fs/promises";
              import * as path from "node:path";

              const homeDir = process.env.HOME ?? "/data/opencode-home";
              const targetProjectID = (process.env.OPENCODE_PROJECT_ID ?? "").trim();
              if (!targetProjectID) {
                throw new Error("Missing OPENCODE_PROJECT_ID");
              }

              const projectDir = path.join(
                homeDir,
                ".local",
                "share",
                "opencode",
                "storage",
                "project",
              );

              let entries = [];
              try {
                entries = await fs.readdir(projectDir, { withFileTypes: true });
              } catch {
                // nothing to prune
              }

              for (const entry of entries) {
                if (!entry.isFile() || !entry.name.endsWith(".json")) {
                  continue;
                }
                if (entry.name === "global.json") {
                  continue;
                }
                if (entry.name === `${targetProjectID}.json`) {
                  continue;
                }
                const filePath = path.join(projectDir, entry.name);
                let parsed;
                try {
                  parsed = JSON.parse(await fs.readFile(filePath, "utf8"));
                } catch {
                  continue;
                }
                if (parsed?.worktree === "/data") {
                  await fs.unlink(filePath).catch(() => {});
                }
              }
              EOF

              bun /tmp/opencode-project-prune.mjs || true
              rm -f /tmp/opencode-project-prune.mjs

              # Migrate existing session records so the Web UI can list them under a single directory.
              # Opencode stores sessions under `storage/session/<projectID>/` where projectID is the git root commit.
              # We rewrite all `/data/...` sessions into the `/data` git project and normalize `directory=/data`.
              cat > /tmp/opencode-session-dir-migrate.mjs <<'EOF'
              import * as fs from "node:fs/promises";
              import * as path from "node:path";

              const homeDir = process.env.HOME ?? "/data/opencode-home";
              const targetDirectory = "/data";
              const targetProjectID = (process.env.OPENCODE_PROJECT_ID ?? "").trim();
              if (!targetProjectID) {
                throw new Error("Missing OPENCODE_PROJECT_ID");
              }
              const sessionRoot = path.join(
                homeDir,
                ".local",
                "share",
                "opencode",
                "storage",
                "session",
              );

              function shouldMigrateDirectory(directory) {
                if (typeof directory !== "string") {
                  return false;
                }
                return (
                  directory === targetDirectory || directory.startsWith(`${targetDirectory}/`)
                );
              }

              function getUpdatedTime(parsed) {
                const updated = parsed?.time?.updated;
                return typeof updated === "number" && Number.isFinite(updated) ? updated : 0;
              }

              async function readSessionJson(filePath) {
                try {
                  const raw = await fs.readFile(filePath, "utf8");
                  return JSON.parse(raw);
                } catch {
                  return null;
                }
              }

              async function writeSessionJsonAtomic(filePath, parsed) {
                const tmpPath = `${filePath}.tmp.${process.pid}.${Date.now()}`;
                const content = `${JSON.stringify(parsed, null, 2)}\n`;
                await fs.writeFile(tmpPath, content, "utf8");
                await fs.rename(tmpPath, filePath);
              }

              async function normalizeAndMoveSession(input) {
                const sourcePath = input.sourcePath;
                const filename = input.filename;
                const parsed = input.parsed;

                if (!shouldMigrateDirectory(parsed.directory)) {
                  return;
                }

                const destDir = path.join(sessionRoot, targetProjectID);
                const destPath = path.join(destDir, filename);
                if (
                  sourcePath === destPath &&
                  parsed.directory === targetDirectory &&
                  parsed.projectID === targetProjectID
                ) {
                  return;
                }

                parsed.directory = targetDirectory;
                parsed.projectID = targetProjectID;

                await fs.mkdir(destDir, { recursive: true });

                if (sourcePath !== destPath) {
                  const existing = await readSessionJson(destPath);
                  if (existing && typeof existing === "object") {
                    const existingUpdated = getUpdatedTime(existing);
                    const sourceUpdated = getUpdatedTime(parsed);
                    const winner = existingUpdated >= sourceUpdated ? existing : parsed;
                    if (winner && typeof winner === "object") {
                      winner.directory = targetDirectory;
                      winner.projectID = targetProjectID;
                      await writeSessionJsonAtomic(destPath, winner);
                    }
                    await fs.unlink(sourcePath).catch(() => {});
                    return;
                  }
                }

                await writeSessionJsonAtomic(destPath, parsed);
                if (sourcePath !== destPath) {
                  await fs.unlink(sourcePath).catch(() => {});
                }
              }

              async function migrateOnce() {
                let projectEntries;
                try {
                  projectEntries = await fs.readdir(sessionRoot, { withFileTypes: true });
                } catch {
                  return;
                }

                for (const projectEntry of projectEntries) {
                  if (!projectEntry.isDirectory()) {
                    continue;
                  }

                  const projectRoot = path.join(sessionRoot, projectEntry.name);
                  let entries;
                  try {
                    entries = await fs.readdir(projectRoot, { withFileTypes: true });
                  } catch {
                    continue;
                  }

                  for (const entry of entries) {
                    if (!entry.isFile()) {
                      continue;
                    }
                    const name = entry.name;
                    if (!name.startsWith("ses_") || !name.endsWith(".json")) {
                      continue;
                    }
                    const filePath = path.join(projectRoot, name);
                    const parsed = await readSessionJson(filePath);
                    if (!parsed || typeof parsed !== "object") {
                      continue;
                    }

                    await normalizeAndMoveSession({
                      filename: name,
                      sourcePath: filePath,
                      parsed,
                    });
                  }
                }
              }

              const watch = process.argv.includes("--watch");
              do {
                await migrateOnce();
                if (!watch) {
                  break;
                }
                await new Promise((resolve) => setTimeout(resolve, 30_000));
              } while (true);
              EOF

              # One-shot migration for existing sessions.
              bun /tmp/opencode-session-dir-migrate.mjs || true

              # Background watcher to keep new sessions visible in Web UI without needing worker changes.
              bun /tmp/opencode-session-dir-migrate.mjs --watch >/dev/null 2>&1 &

              opencode_bin=""
              for c in \
                /usr/local/bun/install/global/node_modules/opencode-linux-x64-baseline/bin/opencode \
                /usr/local/bun/install/global/node_modules/opencode-linux-x64/bin/opencode \
                /usr/local/bun/install/global/node_modules/opencode-linux-x64-musl/bin/opencode; do
                if [ -x "$c" ]; then
                  opencode_bin="$c"
                  break
                fi
              done

              if [ -z "$opencode_bin" ]; then
                echo "opencode binary not found" >&2
                exit 1
              fi

              # Opencode's Web UI (1.1.30+) sends `directory` with a trailing slash (e.g. `/data/`),
              # but opencode server treats it as an exact match and returns an empty session list.
              # Run a tiny proxy on :4096 that normalizes directory strings and forwards to the real server on :4097.
              cat > /tmp/opencode-directory-proxy.mjs <<'EOF'
              const upstream =
                process.env.OPENCODE_PROXY_UPSTREAM ?? "http://127.0.0.1:4097";

              function normalizeDirectory(value) {
                if (!value || typeof value !== "string") {
                  return null;
                }
                if (value === "/") {
                  return value;
                }
                return value.replace(/\/+$/, "");
              }

              const excludedWebSocketHeaders = new Set([
                "connection",
                "host",
                "sec-websocket-accept",
                "sec-websocket-extensions",
                "sec-websocket-key",
                "sec-websocket-version",
                "upgrade",
              ]);

              function normalizeUrlAndHeaders(req) {
                const url = new URL(req.url);
                const directory = url.searchParams.get("directory");
                const normalizedDirectory = normalizeDirectory(directory);
                if (normalizedDirectory && normalizedDirectory !== directory) {
                  url.searchParams.set("directory", normalizedDirectory);
                }

                const headers = new Headers(req.headers);
                const headerDirectory = headers.get("x-opencode-directory");
                const normalizedHeaderDirectory = normalizeDirectory(headerDirectory);
                if (
                  normalizedHeaderDirectory &&
                  normalizedHeaderDirectory !== headerDirectory
                ) {
                  headers.set("x-opencode-directory", normalizedHeaderDirectory);
                }

                return { url, headers };
              }

              let server;
              server = Bun.serve({
                port: 4096,
                idleTimeout: 0,
                async fetch(req) {
                  const { url, headers } = normalizeUrlAndHeaders(req);
                  const upgrade = headers.get("upgrade")?.toLowerCase() ?? "";
                  if (upgrade === "websocket") {
                    const upstreamUrl = new URL(url.pathname + url.search, upstream);
                    upstreamUrl.protocol = upstreamUrl.protocol === "https:" ? "wss:" : "ws:";

                    const forwardHeaders = {};
                    for (const [key, value] of headers.entries()) {
                      const lower = key.toLowerCase();
                      if (excludedWebSocketHeaders.has(lower)) {
                        continue;
                      }
                      forwardHeaders[key] = value;
                    }

                    const ok = server.upgrade(req, {
                      data: {
                        upstreamUrl: upstreamUrl.toString(),
                        headers: forwardHeaders,
                        protocols: headers.get("sec-websocket-protocol") ?? "",
                      },
                    });
                    if (ok) {
                      return;
                    }
                    return new Response("WebSocket upgrade failed", { status: 400 });
                  }

                  const upstreamUrl = new URL(url.pathname + url.search, upstream);
                  if (req.method === "PATCH" && url.pathname.startsWith("/config")) {
                    return new Response("Config updates are disabled in this deployment", {
                      status: 403,
                    });
                  }

                  const upstreamResponse = await fetch(upstreamUrl, {
                    method: req.method,
                    headers,
                    body: req.body,
                    redirect: "manual",
                  });

                  if (req.method === "GET" && url.pathname.startsWith("/config")) {
                    const raw = await upstreamResponse.text();
                    let parsed = null;
                    try {
                      parsed = JSON.parse(raw);
                    } catch {
                      parsed = null;
                    }

                    if (parsed && typeof parsed === "object") {
                      const mcp = parsed.mcp;
                      if (mcp && typeof mcp === "object") {
                        for (const serverName of Object.keys(mcp)) {
                          const entry = mcp[serverName];
                          if (!entry || typeof entry !== "object") {
                            continue;
                          }
                          const headerEntries = entry.headers;
                          if (!headerEntries || typeof headerEntries !== "object") {
                            continue;
                          }
                          for (const headerName of Object.keys(headerEntries)) {
                            const lower = headerName.toLowerCase();
                            if (
                              lower === "authorization" ||
                              lower.includes("token") ||
                              lower.includes("secret") ||
                              lower.includes("key")
                            ) {
                              headerEntries[headerName] = "[redacted]";
                            }
                          }
                        }
                      }
                    }

                    const nextHeaders = new Headers(upstreamResponse.headers);
                    nextHeaders.delete("content-length");
                    return new Response(
                      parsed ? JSON.stringify(parsed) : raw,
                      {
                        status: upstreamResponse.status,
                        headers: nextHeaders,
                      },
                    );
                  }

                  return upstreamResponse;
                },
                websocket: {
                  open(ws) {
                    const info = ws.data ?? {};
                    const protocolsRaw =
                      typeof info.protocols === "string" ? info.protocols : "";
                    const protocols = protocolsRaw
                      .split(",")
                      .map((item) => item.trim())
                      .filter(Boolean);

                    const upstreamSocket = new WebSocket(info.upstreamUrl, protocols, {
                      headers:
                        info.headers && typeof info.headers === "object" ? info.headers : {},
                    });
                    info.upstreamSocket = upstreamSocket;

                    upstreamSocket.addEventListener("open", () => {
                      info.queue = info.queue ?? [];
                      for (const queued of info.queue) {
                        upstreamSocket.send(queued);
                      }
                      info.queue = [];
                    });
                    upstreamSocket.addEventListener("message", (event) => {
                      ws.send(event.data);
                    });
                    upstreamSocket.addEventListener("close", () => {
                      try {
                        ws.close();
                      } catch {}
                    });
                    upstreamSocket.addEventListener("error", () => {
                      try {
                        ws.close();
                      } catch {}
                    });
                  },
                  message(ws, message) {
                    const info = ws.data ?? {};
                    const upstreamSocket = info.upstreamSocket;
                    if (upstreamSocket && upstreamSocket.readyState === WebSocket.OPEN) {
                      upstreamSocket.send(message);
                      return;
                    }
                    info.queue = info.queue ?? [];
                    info.queue.push(message);
                  },
                  close(ws) {
                    const info = ws.data ?? {};
                    const upstreamSocket = info.upstreamSocket;
                    if (upstreamSocket) {
                      try {
                        upstreamSocket.close();
                      } catch {}
                    }
                  },
                },
              });
              EOF

              "$opencode_bin" serve --hostname 127.0.0.1 --port 4097 \
                --cors https://app.opencode.ai \
                --cors https://opencode.ai &
              opencode_pid=$!

              bun /tmp/opencode-directory-proxy.mjs &
              proxy_pid=$!

              cleanup() {
                kill "$opencode_pid" "$proxy_pid" >/dev/null 2>&1 || true
              }
              trap cleanup EXIT INT TERM

              wait -n "$opencode_pid" "$proxy_pid"
              exit_code=$?
              cleanup
              exit "$exit_code"
          env:
            # Store opencode state on the shared /data RWX volume so multiple replicas can serve the same sessions.
            - name: HOME
              value: "/data/opencode-home"
            - name: OPENAI_BASE_URL
              valueFrom:
                secretKeyRef:
                  name: llbot-secrets
                  key: OPENAI_BASE_URL
                  optional: true
            - name: OPENAI_API_KEY
              valueFrom:
                secretKeyRef:
                  name: llbot-secrets
                  key: OPENAI_API_KEY
                  optional: true
            - name: OPENCODE_MODELS
              valueFrom:
                secretKeyRef:
                  name: llbot-secrets
                  key: OPENCODE_MODELS
                  optional: true
            # Optional: enable HTTP basic auth (worker must use the same values).
            - name: OPENCODE_SERVER_USERNAME
              valueFrom:
                secretKeyRef:
                  name: llbot-secrets
                  key: OPENCODE_SERVER_USERNAME
                  optional: true
            - name: OPENCODE_SERVER_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: llbot-secrets
                  key: OPENCODE_SERVER_PASSWORD
                  optional: true
            # MCP token for talesofai MCP server (used by config.json header template).
            - name: NIETA_TOKEN
              valueFrom:
                secretKeyRef:
                  name: llbot-secrets
                  key: NIETA_TOKEN
                  optional: true
          ports:
            - name: http
              containerPort: 4096
          resources:
            requests:
              cpu: 500m
              memory: 512Mi
            limits:
              cpu: 2000m
              memory: 2Gi
          volumeMounts:
            - name: data
              mountPath: /data
      volumes:
        - name: data
          persistentVolumeClaim:
            claimName: bot-data
