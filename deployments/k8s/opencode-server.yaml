apiVersion: v1
kind: Service
metadata:
  name: opencode-server
  namespace: bot
spec:
  selector:
    app: opencode-server
  ports:
    - name: http
      port: 4096
      targetPort: http
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: opencode-server
  namespace: bot
spec:
  replicas: 1
  selector:
    matchLabels:
      app: opencode-server
  template:
    metadata:
      labels:
        app: opencode-server
    spec:
      containers:
        - name: opencode-server
          image: registry.cn-shanghai.aliyuncs.com/talesofai/opencode-bot-agent:latest
          command: ["bash", "-lc"]
          args:
            - |
              set -euo pipefail

              mkdir -p "${HOME}/.local/share/opencode" "${HOME}/.config/opencode"

              if [ -n "${OPENAI_API_KEY:-}" ]; then
                cat > "${HOME}/.local/share/opencode/auth.json" <<EOF
                {
                  "litellm": {
                    "type": "api",
                    "key": "${OPENAI_API_KEY}"
                  }
                }
              EOF
                chmod 600 "${HOME}/.local/share/opencode/auth.json" || true
              fi

              # Generate opencode config from env so OPENCODE_MODELS changes don't require YAML updates.
              cat > /tmp/opencode-config-gen.mjs <<'EOF'
              import * as fs from "node:fs/promises";
              import * as path from "node:path";

              const homeDir = process.env.HOME ?? "/data/opencode-home";
              const configPath = path.join(homeDir, ".config", "opencode", "config.json");
              const raw = (process.env.OPENCODE_MODELS ?? "").trim();
              const models = raw
                ? raw
                    .split(",")
                    .map((entry) => entry.trim())
                    .filter(Boolean)
                : [];
              const unique = Array.from(new Set(models));

              const config = {
                $schema: "https://opencode.ai/config.json",
                ...(unique.length > 0
                  ? {
                      provider: {
                        litellm: {
                          npm: "@ai-sdk/openai-compatible",
                          options: {
                            baseURL: "{env:OPENAI_BASE_URL}",
                          },
                          models: Object.fromEntries(
                            unique.map((name) => [name, { name }]),
                          ),
                        },
                      },
                    }
                  : {}),
                mcp: {
                  talesofai: {
                    type: "remote",
                    url: "https://mcp.talesofai.cn/mcp",
                    enabled: true,
                    timeout: 600000,
                    headers: {
                      "x-token": "{env:NIETA_TOKEN}",
                    },
                  },
                },
              };

              await fs.mkdir(path.dirname(configPath), { recursive: true });
              const tmpPath = `${configPath}.tmp`;
              await fs.writeFile(tmpPath, JSON.stringify(config, null, 2), "utf8");
              await fs.rename(tmpPath, configPath);
              EOF

              bun run /tmp/opencode-config-gen.mjs
              rm -f /tmp/opencode-config-gen.mjs

              # Ensure `/data` is present as a project in the Web UI.
              # Sessions are migrated to `directory=/data`, and the Web UI lists sessions via:
              #   GET /session?directory=<current project worktree>
              projectFile="${HOME}/.local/share/opencode/storage/project/data.json"
              mkdir -p "$(dirname "$projectFile")"
              now_ms="$(( $(date +%s) * 1000 ))"
              cat > "$projectFile" <<EOF
              {
                "id": "data",
                "worktree": "/data",
                "sandboxes": [],
                "time": {
                  "created": ${now_ms},
                  "updated": ${now_ms}
                },
                "icon": {
                  "color": "cyan"
                }
              }
              EOF

              # Migrate existing session records so the Web UI can list them under a single directory/project.
              # opencode Web lists sessions via `GET /session?directory=<worktree>` (exact match) and also groups by `projectID`.
              cat > /tmp/opencode-session-dir-migrate.mjs <<'EOF'
              import * as fs from "node:fs/promises";
              import * as path from "node:path";

              const homeDir = process.env.HOME ?? "/data/opencode-home";
              const targetDirectory = "/data";
              const targetProjectID = "data";
              const sessionRoot = path.join(
                homeDir,
                ".local",
                "share",
                "opencode",
                "storage",
                "session",
              );

              function shouldMigrateDirectory(directory) {
                if (typeof directory !== "string") {
                  return false;
                }
                return (
                  directory === targetDirectory || directory.startsWith(`${targetDirectory}/`)
                );
              }

              function getUpdatedTime(parsed) {
                const updated = parsed?.time?.updated;
                return typeof updated === "number" && Number.isFinite(updated) ? updated : 0;
              }

              async function readSessionJson(filePath) {
                try {
                  const raw = await fs.readFile(filePath, "utf8");
                  return JSON.parse(raw);
                } catch {
                  return null;
                }
              }

              async function writeSessionJsonAtomic(filePath, parsed) {
                const tmpPath = `${filePath}.tmp.${process.pid}.${Date.now()}`;
                const content = `${JSON.stringify(parsed, null, 2)}\n`;
                await fs.writeFile(tmpPath, content, "utf8");
                await fs.rename(tmpPath, filePath);
              }

              async function normalizeAndMoveSession(input) {
                const sourcePath = input.sourcePath;
                const filename = input.filename;
                const parsed = input.parsed;

                if (!shouldMigrateDirectory(parsed.directory)) {
                  return;
                }

                const destDir = path.join(sessionRoot, targetProjectID);
                const destPath = path.join(destDir, filename);
                if (
                  sourcePath === destPath &&
                  parsed.directory === targetDirectory &&
                  parsed.projectID === targetProjectID
                ) {
                  return;
                }

                parsed.directory = targetDirectory;
                parsed.projectID = targetProjectID;

                await fs.mkdir(destDir, { recursive: true });

                if (sourcePath !== destPath) {
                  const existing = await readSessionJson(destPath);
                  if (existing && typeof existing === "object") {
                    const existingUpdated = getUpdatedTime(existing);
                    const sourceUpdated = getUpdatedTime(parsed);
                    const winner = existingUpdated >= sourceUpdated ? existing : parsed;
                    if (winner && typeof winner === "object") {
                      winner.directory = targetDirectory;
                      winner.projectID = targetProjectID;
                      await writeSessionJsonAtomic(destPath, winner);
                    }
                    await fs.unlink(sourcePath).catch(() => {});
                    return;
                  }
                }

                await writeSessionJsonAtomic(destPath, parsed);
                if (sourcePath !== destPath) {
                  await fs.unlink(sourcePath).catch(() => {});
                }
              }

              async function migrateOnce() {
                let projectEntries;
                try {
                  projectEntries = await fs.readdir(sessionRoot, { withFileTypes: true });
                } catch {
                  return;
                }

                for (const projectEntry of projectEntries) {
                  if (!projectEntry.isDirectory()) {
                    continue;
                  }

                  const projectRoot = path.join(sessionRoot, projectEntry.name);
                  let entries;
                  try {
                    entries = await fs.readdir(projectRoot, { withFileTypes: true });
                  } catch {
                    continue;
                  }

                  for (const entry of entries) {
                    if (!entry.isFile()) {
                      continue;
                    }
                    const name = entry.name;
                    if (!name.startsWith("ses_") || !name.endsWith(".json")) {
                      continue;
                    }
                    const filePath = path.join(projectRoot, name);
                    const parsed = await readSessionJson(filePath);
                    if (!parsed || typeof parsed !== "object") {
                      continue;
                    }

                    await normalizeAndMoveSession({
                      filename: name,
                      sourcePath: filePath,
                      parsed,
                    });
                  }
                }
              }

              const watch = process.argv.includes("--watch");
              do {
                await migrateOnce();
                if (!watch) {
                  break;
                }
                await new Promise((resolve) => setTimeout(resolve, 30_000));
              } while (true);
              EOF

              # One-shot migration for existing sessions.
              bun /tmp/opencode-session-dir-migrate.mjs || true

              # Background watcher to keep new sessions visible in Web UI without needing worker changes.
              bun /tmp/opencode-session-dir-migrate.mjs --watch >/dev/null 2>&1 &

              for c in \
                /usr/local/bun/install/global/node_modules/opencode-linux-x64-baseline/bin/opencode \
                /usr/local/bun/install/global/node_modules/opencode-linux-x64/bin/opencode \
                /usr/local/bun/install/global/node_modules/opencode-linux-x64-musl/bin/opencode; do
                if [ -x "$c" ]; then
                  exec "$c" serve --hostname 0.0.0.0 --port 4096 \
                    --cors https://app.opencode.ai \
                    --cors https://opencode.ai
                fi
              done

              echo "opencode binary not found" >&2
              exit 1
          env:
            # Store opencode state on the shared /data RWX volume so multiple replicas can serve the same sessions.
            - name: HOME
              value: "/data/opencode-home"
            - name: OPENAI_BASE_URL
              valueFrom:
                secretKeyRef:
                  name: llbot-secrets
                  key: OPENAI_BASE_URL
                  optional: true
            - name: OPENAI_API_KEY
              valueFrom:
                secretKeyRef:
                  name: llbot-secrets
                  key: OPENAI_API_KEY
                  optional: true
            - name: OPENCODE_MODELS
              valueFrom:
                secretKeyRef:
                  name: llbot-secrets
                  key: OPENCODE_MODELS
                  optional: true
            # Optional: enable HTTP basic auth (worker must use the same values).
            - name: OPENCODE_SERVER_USERNAME
              valueFrom:
                secretKeyRef:
                  name: llbot-secrets
                  key: OPENCODE_SERVER_USERNAME
                  optional: true
            - name: OPENCODE_SERVER_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: llbot-secrets
                  key: OPENCODE_SERVER_PASSWORD
                  optional: true
            # MCP token for talesofai MCP server (used by config.json header template).
            - name: NIETA_TOKEN
              valueFrom:
                secretKeyRef:
                  name: llbot-secrets
                  key: NIETA_TOKEN
                  optional: true
          ports:
            - name: http
              containerPort: 4096
          resources:
            requests:
              cpu: 500m
              memory: 512Mi
            limits:
              cpu: 2000m
              memory: 2Gi
          volumeMounts:
            - name: data
              mountPath: /data
      volumes:
        - name: data
          persistentVolumeClaim:
            claimName: bot-data
